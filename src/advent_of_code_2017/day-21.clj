(ns advent-of-code-2017.day-21
  (:require [clojure.string :as str]
            [advent-of-code-2017.core :as core]))

(def input (core/read-input "day21.txt"))

(def start-board [[\. \# \.] [\. \. \#] [\# \# \#]])

(defn variations
  "Returns a vector of all possible boards generated by flipping and rotating
  the given board."
  [board]
  (let [v-board (mapv vec board)
        reversed (reverse v-board)
        transposed (core/transpose v-board)
        map-reversed (mapv reverse v-board)
        reverse-transposed (reverse transposed)]
    [v-board
     reversed
     transposed
     map-reversed
     reverse-transposed
     (reverse map-reversed)
     (core/transpose reversed)
     (mapv reverse reverse-transposed)]))

(defn print-board
  [board]
  (println (str/join "\n" (map #(apply str %) board))))

(defn add-rule
  [rules [rule-pattern rule-product]]
  (into rules (map #(vector % rule-product) (variations rule-pattern))))

(defn parse-rule
  [s]
  (mapv #(map vec (str/split % #"/")) (str/split s #" => ")))

(defn parse-rules
  [input]
  (->> input
    str/split-lines
    (map parse-rule)
    (reduce add-rule {})))

(defn break-into
  [square-size board]
  (->> board
    (map #(partition square-size %))
    (partition square-size)
    (map #(apply map list %))))

(defn apply-rules
  [rules broken-board]
  (map (fn [row-of-squares]
         (map #(get rules %) row-of-squares))
       broken-board))

(defn fuse
  [broken-board]
  (mapcat #(apply map concat %) broken-board))

(core/defn-split step
  [rules | board]
  (let [square-size (if (zero? (mod (count board) 2)) 2 3)]
    (->> board
      (break-into square-size)
      (apply-rules rules)
      fuse)))

(core/defn-split lights-on-after
  [input start-board | iterations]
  (-> input
    parse-rules
    step
    (iterate start-board)
    (->> (drop iterations)
         first
         (map #(count (filter #{\#} %)))
         (reduce +))))

(def solution-after (lights-on-after input start-board))

(solution-after 5)
(solution-after 18)
